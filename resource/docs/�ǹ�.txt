http://www.privatecloud.com/2010/12/29/cloud-architecture-patterns-vm-pipeline/?fbid=O5tu476JdAd

    * Cloud Architecture Patterns: Stateless VM
    * Cloud Architecture Patterns: Aspectual Centralization
    * Cloud Architecture Patterns: VM Pool
    * Cloud Architecture Patterns: VM Factory
    * Cloud Architecture Patterns: Overview
    * Cloud Architecture Patterns: App VM
    * Cloud Architecture Patterns: Facade VM


ARadon

Radon(라돈)은 그리스 신화에 나오는 커다란 뱀 형상의 드래곤으로 헤스페리데스의 황금사과를 지키는 괴물로, 불사의 존재였습니다.
신화에 따르면 모든 신들의 여왕 헤라(Hera)는 제우스(Zeus)와 결혼할 때 제우스에게 황금사과나무를 결혼선물로 받습니다. 
헤라는 이 나무를아틀라스(Atlas)의 세딸들인 헤스페리데스(Hesperides)에게 지키게 합니다. 그러나 그녀들이 제대로 이 나무를 지키지못하여 헤라는 라돈(Ladon)이라는 용에게 이 나무를 지키게 합니다.  

후에 헤라클레스(Hercules)는 12가지 노역중 하나로 이 황금사과를 가지러 아틀라스산으로 가는데 헤라클레스의 황금사과 임무는 아틀라스가 대신 해 주었기 때문에, 헤라클레스는 라돈과 싸우지 않았습니다.

과일 나무를 지키고 있는 커다란 뱀의 이야기는 고대 근동지역에서 흔히 볼 수 있는 전설로
에리스토파네스의 희곡 개구리들에서도 라돈이 언급되고 있는데 여기서 라돈은 100개의 머리를 가지고 있고 서로 다른 말을 할 수 있다고 합니다.



목표 : 

HTTP Protocol을 이용해 추상화된 형태의 공용 서비스 제공 : 
추상화된 분산(Process, Repository) Let   
서비스 생태계 구축






비용, 품질, 기간

혹자는 소프트웨어 개발에 있어서 비용,품질,일정을 의자뺐기 게임에 비유하곤 합니다. 
보통의 경우에는 의자가 한개, 운이 좋다면 의자 2개를 두고서 빙글 빙글 돌다가 먼저 앉는 게임말이죠. 

서비스 개발에 있어서 비용과 품질,일정은 일반적으로 프로젝트의 트리플 제약 조건이 되며 
종종 불가능해 보이는 세가지 목표를 모두 충족시키기 위해 CMMI 등의 조직의 프로세스 개선을 시도하려는 시도는 꾸준이 있어왔지만
많은 경우에 과거를 다시 한번 반복했을 뿐이었습니다. 

저는 휠러의 "전산학의 모든 문제는 또 다른 수준의 간접층으로 해결할 수 있다." 라는 유명한 말을 토대로 좀 다른 시도를 해보기로 했습니다. 
(휠러는 추가적으로 "그러나 그러면 또 다른 문제가 생기는 것이 일반적이다" 라는 말도 덧붙였습니다. )


다른 시도라고는 하지만 코드의 중복을 해결하기 위해 라이브러리가 나왔고 구조의 중복을 해결하기 위해 프레임 워크가 나왔다면
서비스의 중복을 해결하기위해 서비스 플랫폼이 필요하지 않을까? 라는 상식적인 생각에 기인합니다. 


서비스 플랫폼이란 결국 각각의 서비스를 돌릴수 있는 플랫폼 서비스(PasS)의 역할을 하는 서비스를 말하며 사실 그 자체로 몇가지의 embed common 서비스를 제공하기 때문에
PasS와 SaaS이 중간정도가 맞겠군요.
그럼 서비스 플랫폼을 어떻게 만들어야 할까? 부터 고민을 했습니다. 





Framework vs Service

 


Soap와 Restful Service 방법의 비교.


서비스의 중복 문제에 대하여 이전에 Soap 웹서비스가 그러한 것을 해줄것이라고 기대한적이 있었고 또 일부의 사람들은 아직 충분히 성숙하지 못했을 뿐이라며 그러한 기대를 아직 가지고 있습니다.
그러나 저는 웹서비스가 일반화 되지 못한것은 기술의 성숙의 문제와 관계가 없다고 생각합니다. 

SOAP 웹서비스의 가장 큰 단점은 복잡성입니다. 
SOAP 자체가 복잡성이 높다고 보기는 어려울 수도 있지만 
SOAP 헤더, 바디, Fault등의 envelope 방법자체도 그렇고 보안, 트랜잭션 등 부수적인 문제해결을 위한 다양한 표준은 사실 이해하기 쉬운 부분도 아닙니다. 
(여기서 이야기하는 복잡도는 물론 다른 방법에 비하여 상대적인 관점입니다.)

한가지 또 단점은 상대적으로 무겁다는 겁니다. 
이것은 통신기술에 의존하지 않는 표준이라는 특성에 기인하는데 시시콜콜한 것이 너무 많아서 보통의 경우 도구가 없이는 개발하기가 꽤나 험난합니다. 

물론 Soap가 가지는 표준의 힘은 마치 국회에서 새로운 법을 지정하면 그 법에 의해 시스템이 돌아가는 것처럼 
표준이 있고 그 표준을 지키면 그 서비스는 표준에서 이야기하는 것들이(상호운영, 보안, 라우팅,...) 시스템에서 돌아갈 거라는 확신을 가질 수 있다는데 장점이 있습니다.
즉 내가 SOAP 표준을 지켜 서비스를 구현하면 기술에 대한 세세한 동작 메커니즘을 설명하지 않더라도 전혀 다른 플랫폼이나 언어로 그 서비스를 사용할 수 있을 것이라는 기대를 가질수 있습니다. 
(물론 현실적으로 이게 100% 맞는 이야기인지는 SOAP으로 프로젝트를 해 본 사람이라면 의문을 던질 것이지만...)



그래서 저는 서비스 플랫폼의 프로토콜 방식으로 SOAP 웹서비스보다는 REST Call을 생각하게 되었습니다.  
RESTful 웹 서비스의 강점은 단순함과 간결함입니다. 잘 구현된 RESTful 웹서비스는 간결하고 일관된 인터페이스(Uniform Interface)구조를 지니고 있어 어려움 없이 쉽게 사용이 가능하다.

물론 RESTful은 보안, 정책 등에 표준이 없기 때문에 이런것까지 고려해서 추가 구현을 해야 한다든가 HTTP Protocol에 의존적이라는 등의 단점이 있습니다. 
그러나 REST의 가장 큰 장점인 간결함의 힘도 무시할 수 없습니다.

단순함 간결함은 직관적이며 쉽게 개발하거나 사용할 수 있어 기술의 전파 속도가 굉장히 빠릅니다. 단순함이나 간결함을 가지는 기술은 굳이 따로 배우지 않더라도 바로 사용할 수 있는 힘이 있고,
따라서 아키텍처나 설계에 있어 단순함, 간결함을 매우 강조하는 이유가 여기에 있습니다.

물론 두 가지의 기술 중에 한 가지만 고집하고 사용할 필요는 없습니다. 
여력이 되는데로 모두 배우고 상황에 맞춰 선택하여 사용해도 상관이 없겠지만 여러 웹 사이트에서 자료를 수집해 보니 역시 단순한 기술의 전파력이 무섭다는 것을 알 수 있었습니다.

   * 아마존은 SOAP과 REST 서비스 모두 제공하는데 85% 정도가 REST 서비스를 사용하는 것으로 알려졌다. (2003년)
   * Google은 SOAP 기술에 대해 그리 좋게 보지 않고 있으며 더 이상 SOAP API에 대한 지원을 하지 않는다. (http://radar.oreilly.com/archives/2006/12/google-depreciates-SOAP-API.html)
   * 야후는 현재까지 SOAP API를 제공할 계획이 없다. (http://developer.yahoo.com/faq/#soap)

결국 저는 REST방식으로 메시지를 주고 받는 Service Platform을 만들기로 합니다. 




그럼 다시 방법의 구현문제를 잠시 떠나서 왜 이러한 것이 필요할까에 대해 예를 들어보겠습니다.  



예컨데 여러분이 작은 게시판을 만든다고 가정해보면 

해야할 기능은 그냥 게시판이라고 하지만 실제 기능을 나누어 보면 몇가지의 다른 서비스로 나누어져 있습니다. 

일련번호를 따기위한 sequence 서비스
등록일을 알아내기 위한 Calendar 서비스
제목과 내용등을 등록하기 위한 repository 서비스
이진 파일을 등록한다면 binary-repository 서비스
추가적으로 인증과 권한 서비스 등등의 작은 서비스등의 결합으로 되어 있습니다. 

그리고 이러한 작은 서비스는 다른 서비스를 만들더라도 비슷하게 사용될 가능성이 무척 높습니다. 
만약 이러한 작은 서비스를 충분히 일반적으로 만들수 있다면 그리고 그 사용이 쉽다면 좀더 복잡한 서비스를 만들 때 
지금 처럼 소스 카피나 Jar 카피 이상의 효과를 가지리라고 생각했습니다. 

여기서 서비스를 일반적으로 만들기란 사실 보이는 것처럼 쉬운 것은 아닙니다. 

예컨데 사용하는 형태에 따라 파일은 0개 혹은 1개 혹은 그 이상을 등록해야 할수도 있고
어떤 게시판은 인증을 사용할수도 혹은 안할수도 있기 때문에 사용자 정보를 관리하기도 하고 안하기도 하고
제목과 내용 그 이상의 추가적인 정보를 관리해야 할때도 있습니다.
HTML규약과 CSS규약을 따르면 좀더 쉽다고는 하지만 화면 템플릿도 매번 바뀌며 등록하고자 하는 데이타가 얽히는 순간 이 작업도 매번 반복이 됩니다. 


이진파일 업로드 서비스 하나만 고려해봐도

첫째 파일 사이즈를 제한시킬수 있어야 하며 동시에 DDos 공격에 대비할수 있어야 한다.
둘째 업로드한 파일이름이 겹치는 경우를 생각해야 한다. 
셋째 업로드한 파일이름이 아스키가 아닌 경우를 생각해야 한다. 이를테면 서버의 OS는 EUC-KR인데 거기에 일본어 이름의 파일을 올릴수 있을까? 
넷째 업로드한 파일의 총 사이즈가 1Tera가 넘을 경우 용량의 문제로 하나의 컴퓨터에 저장하기 어렵다
등등의 고려해야 할 수십가지를 상상할수 있지만 

아이러니 한것은 여러분이 더 많은 것을 고려할수록 일정과 비용이 늘어나며 소스나 jar 카피할때 그 복잡성으로 오히려 재활용도가 떨어지는 역전현상이 일어납니다.

사실 비지니스 서비스 개발자는 이런 시스템성 서비스에 대해 그렇게 많은 시간을 할애할수 없고 매번 그러한 것을 신경써야 한다는 것은 피곤한 일입니다. 

이진 파일은 그렇다고 치고 어떤 서비스는 제목과 내용을 저장하고 어떤 서비스는 제목과 내용과 태그를 저장한다고 해보죠
이 서비스는 재사용이 될수 있을까요? 매번 비슷한 테이블과 비슷한 쿼리를 짜는 일에 지쳤다면 이제 그런일을 "일반적으로" 할수 있는 서비스를 만드는걸 생각해 봐야겠죠.   

앞에서 제가 ARadon은 각각의 머리에 해당하는 서비스를 Rest 방식으로 연결시키주는 Rest Service Platform의 역할을 합니다. 



예컨대

이러한 조금조금의 차이는 게시판서비스라는 하나의 서비스로 결합되었을때  큰 차이를 일으키게 되며 서비스의 재활용이 매우 어렵게 만듭니다.
(물론 코드 복사를 통한 재활용도 재활용이라면 재활용이라고 할수는 있겠지만 그 경우 다시 테스트부터 많은 작업이 다시 요구됩니다. ) 

이러한 서비스의 중복의 문제에 대하여 이미 웹서비스라는 기술이 나와있습니다. 
하지만 누가 어디서 sequence 서비스를 하는지 일단 찾아야 하는 문제가 있고 
그 서비스가 안정적이면서 빨라야 하며..최소 5개 이상의 서비스의 결합 즉 5개 이상의 network IO 속도를 감내해야 합니다. 
게다가 WebService 프로토콜은 배우기도 그리 만만치 않습니다. 





지금까지 개발자의 문제 즉 개발상의 문제에 대해서만 얘기했습니다.
그러나 냉정하게 들릴지 모르지만 고객은 이런 문제에 관심이 없습니다. 고객의 입장에서 중요한점은 무엇일까요?  


개발자를 채찍질해서 그 기능을 두번 만들든 고객입장에서 그건 별로 관심이 없습니다. 
다만 고객이 관심있어야 할 문제는 그래 올라갔다 치자 그 파일들을 다른 서비스에서 쉽게 이용할수 있는가? 에 대한 문제입니다. 
제가 오랫동안 개발자로서 생활하면서 느낀점은 결코 소프트웨어는 소프트 하지 않는다는 사실입니다. 

여기에 이 필드 하나만 추가해 주세요 라는 요구사항이 고작 몇분 많아야 몇시간이면 될것 같은데 왜 개발자가 난감해 하고 
몇개 이것 저것 고쳐달라고 했더니 심각한 얼굴로 그럼 전면 재개발해야 한다는 황당한 소리를 하는지 이해할수 없어 하는 경우를 많이 봅니다. 
네. 저도 이해합니다. 개발자를 떠나서 상식적으로 본다면 이것 저것 조금 바꾸는게 그렇게 많은 비용이 들어서는 안됩니다. 

이건 프로그램이 얼마나 구체적이었는가에 달린 문제입니다. 
예컨데 우리는 보통 내일 오후 2시에 시청앞 광장에서 보자 라고 약속합니다. 

그러나 이걸 프로그램으로 구현하면  2010년 10월 28일 14:01:01.234초에 37°33'58.87"N 126°58'40.63"E 에서
본청 첫번째 출입문을 기준으로 45도 각도로 12.3미터 떨어진 곳에서 보자. 라고 구현됩니다.
어떤 프로그램은 거기서 시선은 N45도 상방 93도 각도로 옷은 파란색 남방에 왼손 두번째 손가락은 아래로 향하게 해라 라는 조건을 주는 경우도 있습니다. 

그러다 문득 아 내일 오후에 말고 저녁쯤에 회사앞에서 보는게 낫겠다 라고 하는 순간 해당 프로그램은 대응하기 어렵게 됩니다. 

사람은 이런 추상성을 익숙하게 사용하지만 프로그램이 구체적으로 작성되면 이런 추상성에 거의 대응을 하지 못합니다. 
그래서 프로그램은 좀더 일반적인 서비스에 기반해서 작성될수 있다면 이런 변동에 좀더 쉽게 응대를 할수 있습니다. 

예를 들어 Aradon의 저장 서비스는 필드의 수나 타입에 크게 구애받지 않습니다. 즉 어느날 A라는 필드를 새로 저장해야 겠다고 하더라도  
새로 레파지토리를 재 설계해야 할 필요가 없습니다.  혹자는 이렇게 말할수도 있습니다. 

아니 그럼 애초에 처음부터 그렇게 짜면 되지 않냐고?
아쉽지만 그렇게 프로그램을 짜는 것은 무척 어려운 기법에 속합니다. 
처음에 말한바와 같이 고급 개발자와 충분한 일정이 의자를 차지하면 적당한 가격은 의자에 앉을수가 없습니다. 

고객의 입장에서 볼때 이 프로젝트가 성공할지 어떨지 모르는 상태에서 많은 비용을 추가 하기 곤란한 경우가 많습니다. 
그래서 처음에는 비교적 빠른 시간에 저렴한 비용으로 개발하기를 원하죠.
그러나 운이 좋아 그 프로젝트가 아주 성공했다고 하죠. 기뻐할일이 아닙니다. 더 심각한 문제가 생기니까요.
서비스가 너무 인기를 끌어서 사용자가 많아짐에 따라 분산을 고려해야 합니다. 
개발자는 다시 말합니다. 전면 재개발해야 한다고.
분산은 매우 어려운 프로그래밍 기법이고 분산이 아닌 기존 서비스를 분산으로 만드는 것은 그것보다 더 어렵습니다.  
추가적으로 관리도 매우 어려워지는 문제입니다. 그리고 이전 서비스와의 연계성도 매우매우 힘들어집니다. 
당장 사용자가 로그인되어 있다는 상태(즉 세션)를 어떻게 관리 해야 하는가 하는 기초적인 문제부터 고민을 해야 합니다. 

 





  

   
 


시장의 관점에서 보면. 

구글과 MS 그리고 IBM, 아마존등 소프트웨어 회사에서 클라우드 서비스를 합니다. 
앱 서비스 
스마트폰 그리고 패드 시리즈등의 새로운 플랫폼이 뜨고 있습니다. 
구글은 크롬이라는 브라우저를 내놓았습니다. 
향상된 네트워크 그리고 조밀한 무선 망이 확대되고 있습니다. 
저가 PC와 UMPC 노트북 업체들이 다시 나타납니다. 
 
 
 ..... -> 




=============== REST - Radon 방식이 어떤 의미가 있는가? 
	
	
	- Pre Maked Usable Service(Service Based Development)
	  단기적인 장점
	
		- Uniform Interface
		- Free Client Platform(Web or Mobile)
		- Free Language
		- Rapid Development(Rapid Prototyping)
		- 
		
		* File Repository
		* Content Repository(CRUDLIS)
		* Security
		* Channel
		* Utility(Crawler, Searcher etc)
		
		
	
	
	- Distribute Service Platform
	  장기적인 장점
	  
		- 안정적인 Service
		- Business 중립적으로 Service의 재활용




=============== SOAP 와 REST

SOAP 
단점은 복잡성이다. SOAP 자체가 복잡성이 높다고 보기는 어려울 수도 있지만 SOAP 헤더, 바디, Fault등의 envelope 방법자체도 그렇고 보안, 트랜잭션 등 부수적인 문제해결을 위한 다양한 표준은 사실 이해하기 쉬운 부분도 아니다. (여기서 이야기하는 복잡도는 REST와 비교해서 하는 이야기이다)
한가지 또 단점은 REST에 비해 무겁다는 것이다. 이것은 통신기술에 의존하지 않는 표준이라는 특성에 기인한다.

장점
    * 언어, 플랫폼 그리고 통신에 중립적
    * 분산 컴퓨팅 환경을 다루기 위해 설계
    * 웹서비스를 위해 보급된 많은 표준 (WSDL, WS-*)과 벤더에서 제공하는 도구들
    * 에러 처리에 대한 내용이 기본으로 내장
    * 확장성

단점
    * 개념적으로 REST 보다 어렵고 무거움
    * 시시콜콜한 것들이 많아 복잡함(verbose)
    * 개발하기 어렵고, 보통 도구가 필요함


REST
ESTful 웹서비스의 강점은 단순함과 간결함이다. 잘 구현된 RESTful 웹서비스는 간결하고 일관된 인터페이스 구조를 지니고 있어 어려움 없이 쉽게 사용이 가능하다.
반면 RESTful 서비스에 대한 표준은 없어 그 구현방법이 다양해질 수 있다. 한 보안이나 에러처리등과 같은 부수적인 문제는 직접 해결해야 한다.

장점
    * 언어, 플랫폼에 중립적
    * SOAP보단 개발하기 단순함
    * 학습곡선이 작고 도구가 거의 필요없음
    * 간결함. 추가적인 메시징 계층이 없다.
    * 웹에 가까운 설계와 철학(보다 쉬운 MashUp)

단점
    * point-to-point 통신 모델을 가정함. 
    * 보안, 정책 등에 대한 표준이 없음. 이런 것까지 고려해서 구현할 경우 좀 더 어려움.
    * HTTP Protocol에 의존



그러나 간결함의 힘도 무시할 수 없다.

단순함 간결함은 직관적이며 쉽게 개발하거나 사용할 수 있어 기술의 전파 속도가 굉장히 빠르다는 것이다.
단순함이나 간결함을 가지 기술은 굳이 따로 배우지 않더라도 바로 사용할 수 있는 힘이 있다.
따라서 아키텍처나 설계에 있어 단순함, 간결함을 매우 강조하는 이유가 여기에 있다.

SOAP은 통신에 중립적인 구조로 설계되어 있어 부수적인 메시징 정보를 또 포함하고 있다.
HTTP를 이용하여 SOAP을 이용할 경우 이미 HTTP에 포함된 메시징 정보(URL 또는 각종 헤더)에 또 메시징 정보를 포함한다.
이는 편지를 붙이기 위해 주소를 적은 편지봉투를 다시 조금 더 큰 편지봉투에 넣어 보내는 것과 같은 꼴이 된다.

SOAP이 HTTP를 이용하지 않고 다른 프로토콜로 구현한다면 복잡하고 장황한 스팩이 나름대로 의미가 있겠지만 HTTP를 이용한 SOAP 통신이 주를 이루고 있어 위와 같은 상황이 되는게 사실이다.

그러나 SOAP을 무시할 수 없는게 표준이라는 힘에 의해 많은 개발도구들이 SOAP을 지원하여 SOAP을 이용하면 특별한 노력없이 바로 연동이 가능한 점이 있다.

이렇게 표준의 힘을 사용할 것인가 아니면 간결함의 힘에 의지할 것인가에 대한 고민이 있고 이에 대한 논의는 계속되는 상황이다.


트랜드

물론 두 가지의 기술 중에 한 가지만 고집하고 사용할 필요는 없다. 
여력이 되는데로 모두 배우고 상황에 맞춰 선택하여 사용해도 될 것이다. 그러나 앞으로 어떤 기술이 주를 이룰지 예측해보는 것은 가치가 있는 일이다.
여러 웹 사이트에서 자료를 수집해 보니 역시 단순한 기술의 전파력이 무섭다는 것을 알 수 있다.

    아마존은 SOAP과 REST 서비스 모두 제공하는데 85% 정도가 REST 서비스를 사용하는 것으로 알려졌다. (2003년)
    Google은 SOAP 기술에 대해 그리 좋게 보지 않고 있으며 더 이상 SOAP API에 대한 지원을 하지 않는다. (http://radar.oreilly.com/archives/2006/12/google-depreciates-SOAP-API.html)
    야후는 현재까지 SOAP API를 제공할 계획이 없다. (http://developer.yahoo.com/faq/#soap)

 
항상 우수한 기술이나 표준 기술이 이런 전쟁에서 이겨온 것은 아니다.
1997년도 즈음 CORBA가 나왔을때 그 기술의 비전과 우수성만 보고 온 세상은 CORBA로 통합될 줄 알았다.
그러나 현실은 그렇지 않았다. 배우기 어렵고 성숙한 구현기술이 부족한 CORBA는 자취를 감추고 IIOP만 J2EE 스팩에 남아있을뿐이다.

SOAP이 CORBA와 같은 길을 갈 것 같다는 생각이 드는 이유는 뭘까?





PS...
여기서 휠러가 지적한 또다른 문제란 레이어를 통한 간접과 계층화는 공간과 시간의 부담을 추가하고 코드의 가독성을 해칠수 있다는 문제점등을 예로 들수 있습니다. 
보통의 경우에는 공간과 공간상의 추가 부담은 그리 크지 않기 때문에 일반적으로 큰 관심사가 되지 못합니다. 
대부분의 경우 추가적인 포인터 참조나 서브루틴 호출에 의한 시간 지연은 전반적인 구조 개선에 비할때 사소한 수준에 그칩니다. 
사실 요즘의 현대적인 프로그래밍 언어들은 추가적인 유연성을 얻기 위한 목적으로 일부 연산들의 경우 항상 하나의 간접층을 거치도록 하는 경향을 보이고 있습니다. 
예를 들어 java나 C#의 경우 객체에 대한 모든 접근이 하나의 포인터 간접을 거치게 하는데, 이는 쓰레기 수거를 위한 것입이다. 
또한 Java에서는 인스턴스 메서드에 대한 거의 모든 호출이 하나의 조회 테이블을 통해서 분배되는데, 
이는 다른 클래스를 상속하는 클래스들이 실행시점에서 메서드를 재 정의 할 수 있도록 하기 위한 것입니다.

모든 객체 접근과 메서드 호출에 부가되는 이러한 추가부담에도 불구하고 두 플랫폼은 시장에 선전을 펼치고 있습니다. 
어떤 경우에서는 개발자가 코드에 집어넣은 간접을 컴파일러가 최적화를 통해서 제거하기도 합니다. 
대부분의 컴파일러들은 함수를 호출하는 것이 함수의 코드를 호출지점에 직접 삽입하는 것(소위 인라인 함수_보다 비싼 경우 자동적으로 그러한 인라인 처리를 수행합니다.

사실 공간과 시간이 부담이 크게 문제가 되지 않는다면 코드의 가독성은 어떨까요?(즉 유지 보수의 문제와 연결됩니다.) 
코드의 가독성에 대한 간접의 영향은 아주 중요한 문제입니다. 
지난 50년간 CPU의 속도는 엄청나게 빨라진 반면 코드를 이해하는 사람의 능력은 별로 발전하지 않았다는 점을 감안한다면 충분히 이해할 수 잇을 것입니다. 
그래서 애자일 프로세스 옹호자들은 오늘이 구체적인 요구가 아니라 미래에 생길 수도 있는 애매하고 명시되지 않는 요구사항들을 처리하기 위해 계층들을 도입할 때에는 
불필요한 계층을 넣지 않도록 아주 신중해야 한다고 조언합니다. 
스몰더스는 이에 대해 성능 안티패턴을 논의하면서 계층은 케이크를 위한 것이지 소프트웨어를 위한것이 아니다 라고 비꼰 바 있다.






=============== Radon은 3가지 개발

	- 고객 - 개발자의 2Layer가 아닌
	- 고객 - 서비스 개발자 - Radon 개발자 - CommonService 개발자의 4 Layer 형태를 가진다. 
	
	
	
	왜 프레임워크를 사용하나
역사가 그리 길지 않은 자바가 짧은 시간에 대중화되면서 기술 개발 주기의 문제점들을 초래하고 있다. 새로운 API와 서비스가 지속적으로 개발되고 있고, 또한 많은 자바 기술 업체는 이
를 경쟁적으로 구현해 자신의 소프트웨어에 포함시키고 있으며 지속적인 새로운 기술 개발로 인해 최신 기술도 금방 구식으로 전락되고 있는 현실이다.

프레임워크는 개발자가 애플리케이션을 상호작용하는 객체들의 집합으로 나누어 재사용할 수 있는 방법이다. 프레임워크
는 프레임워크 컴포넌트들이 구현할 인터페이스, 컴포넌트간의 제어흐름(flow of control), 컴포넌트와 시스템간의 관계를 정의하고 있다. 

표준 인터페이스와 표준 상호작용은 기존의 컴포넌트를 연동, 배합, 그리고 기존의 핵심 컴포넌트 집합으로 부터 다양한 시스템 개발을 가능하게 해준다.
자바 서버 애플리케이션 프레임워크 자바의 AWT와 스윙을 사용해 GUI 화면을 만들어 본 개발 자는 자바의 이벤트 프레임워크와 자바빈 프레임워크를 다 활용해봤을 것이다. 

하지만 서버 애플리케이션을 위한 범용적인 프레임워크는 아직은 생소하게 느껴질 것이다. 
그리고 JSP/Servlet/EJB를 위한 컨테이너 또한 일종의 서버 애플리케이션을 위한 프레임워크이다. 

하지만 이번 연재에서 다루고자 하는 자바 서비스 프레임워크는 좀더 범용적이고 대다수의 서버 애플리케이션을 작성하는 데 적용할 수 있는 것에 대한 소개라 할 수 있다. 

대표적인 예로서 아파치 그룹의 아발론 프로젝트와 HP-Bluestone이 이끌어 가고 있는 JSF(Java Services Framework) 스펙(JSR 111)의참조구현 모델인 CSF(Core Services Framework)를 들수 있다.
아발론은 아파치 그룹의 특징인 오픈소스 형태로 지속적으로 개발이 이뤄지고 있으며 현재 4.x 버전이 배포되고 있다. 

아파치 그룹의 자카르타 프로젝트에서는 자바와 관련된 다양한오픈소스 프로젝트들이 진행되고 있다. 
그리고 CSF(Core Services Framework)는 HP-Bluestone에서 스펙을 주도해 JSR 111을 작성하고 현재 전문가 그룹에 의한 첫 번째 리뷰를 마친 상태다. 
앞으로 최종 스펙이 나오기까지는 약간의 시간이 소요될 것이다. 재미있는 사실은 CSF의 전문가 그룹에 아파치 그룹이 참가하고 있고 CSF 역시 오픈소스로 무료로 제공하고


자바 서비스 프레임워크 기초 다지기
2001 9 23
inside Linux Happy Hacking
22 인사이드 리눅스
현재 많은 서버 애플리케이션이 자바 기반으로 개발되고 있다. 객체지향 개발, 컴포넌트 기반 개발 등 많은 방법론이 하나 같
이 재사용을 높이는 데 초점을 맞추고 있다. 하지만 대부분 디자인 또는 구현상의 오류로 이미 개발해 놓은 객체, 컴포넌트를
재사용하지 못하고 재개발하는 사례가 종종 발생한다. 이런 디자인. 구현상의 오류를 최소화할 수 있는 해결책이 바로 자바
서비스 프레임워크이다.
오충현 한국HP 소프트웨어 솔루션 사업부 aramis05@dreamwiz.com
프트웨어를 개발하면서 겪게 되는 가장
큰 어려움 중 하나가 공통으로 사용하게
될 모듈을 도출하는 작업일 것이다. 특히 객체지향, 컴포넌
트 기반 소프트웨어 개발시에는 공통 클래스(또는 컴포넌
트)와 애플리케이션 구조가 그 프로젝트의 성공 여부를 판
가름한다고 해도 과언이 아닐 것이다. 필자 또한 다양한 프
로젝트에 참여해 개발을 해왔지만 항상 공통 모듈과 애플
리케이션 구조를 놓고 고민하게 된다. 특히 자바 프로젝트
의 경우 썬에서 하루가 다르게 내놓는 스펙들, 다양한 컴포
넌트들을 따라가기에도 벅찬 실정이다. 며칠 밤을 고민해
만들어 놓은 컴포넌트를 다른 프로젝트에서는 재사용하기
가 힘든 것이 사실이다.
프레임워크와 클래스 라이브러리
먼저 프레임워크와 클래스 라이브러리는 어떤 차이점이 있
을까. 클래스 라이브러리는 다양한 목적으로 만들어진 클
래스들의 집합으로 JDK에서 기본적으로 제공하는 java.io,
java.net 패키지의 클래스를 예로 들 수 있다. 이 클래스 집
합은 상호작용을 하지만 개발자가 클래스 집합을 직접 호
출해 각각의 클래스가 상호작용하게 된다. 반면 프레임워
크는 클래스간의 상호작용에 대한 모델을 제시하고 이 모
델에 의해 프레임워크 내에서 호출하고 상호작용하게 된
다. 자바의 이벤트 처리 프레임워크를 예로 들 수 있다. 마
우스의 클릭에 대해서 상호작용을 하려는 컴포넌트는 마우
스 리스너 인터페이스를 구현하고 이를 이벤트 처리 프레
임워크에 등록함으로써 마우스가 클릭될 때 프레임워크가
해당 메쏘드를 호출해 준다. 일반적으로 클래스 라이브러
리는 프레임워크의 일부분으로 포함된다. 즉 클래스 라이
브러리와 각 클래스의 상호작용에 대한 모델을 제시해 주
는 것이 프레임워크이다.
자바서비스프레임워크
기초다지기
JSF를 활용한 서버 애플리케이션 개발 1
연재순서 1회2001.9 | 자바서비스프레임워크기초다지기 2회| CSF를이용한자바서비스개발과배포 3회| Servlet/JSP 서비스분석
소
<화면 1> 아발론 프로젝트 홈페이지
JCP(Java Community Process)는 자바에 적용할 수 있는
새로운 기술개발을 목적으로 구성된 조직으로 EJB, JSP, 서블
릿 등 모든 스펙이 이 조직의 절차를 통해 선정되고 지속적으로
유지 보수된다. 일반 개인도 이곳에 참여해 의견을 제시할 수 있
으며, 스펙을 이끌어 나가는 업체는 주로 썬, HP, IBM, BEA,
오라클 등이다. 여기에 JSR(Java Specification Requests)
을 작성해 제출 후에 5단계를 거쳐서 최종 스펙으로 탄생하게
된다. 이 단계를 거치는 도중 몇 번의 리뷰를 하게 되는데 이때
커뮤니티와 전문가 그룹에서 투표를 하게 된다. 이 과정에서 스
펙 개발이 중단되는 경우도 있다. 이 조직의 홈페이지는 www.
jcp.org이다. 이곳에 가면 현재 개발중인 스펙들의 진행 상황을
알 수 있으며 새롭게 개발되고 있는 스펙의 내용을 앞서 접할 수
있다.
새로운 자바 기술을 위한 조직, JCP
JCP의 홈페이지




프레임워크 스펙에 명시된 핵심 서비스(Core Services)를 제공하는 어
떤 시스템에서도 동작한다.
◆ 짧은 학습 기간(Shorter Learning Curve) : 프레임워크에 정의된 추상
적인 인터페이스 집합을 구현함으로써 자바 서비스를 개발할 수 있다.
개발자는 정해진 인터페이스 집합에 대해 한번 이해하고 나면 매우 빠르
게 서비스를 개발할 수 있다. 기존의 표준 API를 사용해 만들어졌기 때
문에 친숙하고 편하게 사용할 수 있다.
◆ 동적 환경구성 지원(Dynamic Configuration Support) : CSF는
JMX(Java Management Extensions)의 스펙을 준수해 운영중에
시스템을 동적으로 구성할 수 있도록 지원한다. CSF는 제어, 관리할 수
있는 실행 환경과 더불어 논리적 애플리케이션으로 조립할 수 있는 특정
서비스 집합을 제공한다. 프레임워크는 <그림 1>에서 볼 수 있듯이
JVM과 업무솔루션 사이에 위치한다.
CSF의 아키텍처
지금부터는 CSF가 어떻게 구성돼 있고 어떤 핵심 컴포넌트들
이 존재하는지를 살펴보자. 프레임워크의 독특한 아키텍처는
유연성이 핵심이다. 자바 표준을 하부 구조로 사용함으로써 기
본 컴포넌트들을 분리시키고 모듈화해 관리, 제어한다. CSF는
몇 개의 새로운 개념의 자바기술, 임베더(embeddors), 커널,
파티션을 자바 기술 영역에 처음으로 소개하고 있다.
<그림 2>에서 볼 수 있듯이 흰색 상자로 표시되는 컴포넌트
들이 CSF가 하부 구조로 제공하는 서비스, 이를 둘러싸고 있
는 커널, 임베더로 구성된다. 이제 각 구성 요소들이 어떤 역할
을 하는지 간단히 살펴보자.
임베더
CSF는 보다 큰 환경(larger context)에 내장될 수 있도록 설
계됐다. 예를 들어 데이터베이스, 애플리케이션 서버, 라우터
등에 내장될 수 있다. 이 때문에 임베더는 외부환경과 통신하
고 서비스에 정보를 전달하는 역할을 한다. 프레임워크 내에
서 임베더의 역할은 커널의 라이프사이클을 관리한다.
커널
커널은 다른 프레임워크 컴포넌트에 기본적인 기능을 제공한
다. 각 컴포넌트 종류마다 커널로부터 다른 종류의 기능을 부
여받는다. 대부분의 경우 커널은 프레임워크 내에서 파티션과
서비스로 취급된다.
서비스
CSF에서 구동되는 서비스는 여러 가지 형태를 갖고 있다. 서
비스는 프레임워크에 정의된 12개의 인터페이스 중 어떤 것도
구현할 수 있다. 이 인터페이스는 프레임워크와 서비스가 어떤
관련이 있는지를 말해준다. 서비스는 표준 자바빈(standard
JavaBean)이 될 수 있으며 더불어 EJB 서버/서블릿 컨테이
너와 같은 복잡한 구조를 가질 수도 있다.
서비스 관리자
서비스 관리자(service manager)는 대부분의 기능이 서비스
개발자에게 공개돼 있으며 프레임워크 내에서 개별적인 서비
스로 표현된다. 일반적으로 서비스 관리자는 프레임워크와 서
비스의 중간매체 역할을 한다. 서비스 관리자는 자신이 관리하
는 서비스를 생성하고 결과적으로 각 서비스 인스턴스는 각각
의 서비스 관리자와 일대일 관계를 가진다. 또한 서비스 관리
자는 각 서비스에게 프레임워크와 상호작용할 수 있는 서비스
컨텍스트를 제공한다. 커널 초기화시 커널이 서비스 관리자를
생성한다.
서비스 컨텍스트
서비스 컨텍스트(Service Context)는 서비스 관리자가 각 서
비스에게 제공하는 하나의 객체로서 서비스가 프레임워크와
상호작용하는 방법을 제공한다. 서비스들은 서비스 인터페이
스를 구현함으로써 서비스 컨텍스트에 대한 참조(reference)를
얻는다.
파티션
파티션은 서비스 집합을 제공하는 특별한 서비스이며 서비스
의 라이프사이클(life cycle)을 관리하는 역할을 한다. 파티션은
자신만의 클래스 로더와 클래스 경로에서 실행된다.
파티션의 기본역할은 서비스의 가시성을 제어하는 것이다.
즉 한 파티션 내의 서비스는 다른 파티션 내의 서비스와 격리
되어 있으며 자신의 파티션 외의 서비스는 찾아서 사용할 수
자바 서비스 프레임워크 기초 다지기
2001 9 25
inside Linux
있다는 것이다. 새로운 애플리케이션 개발시에는 기본이 되
는 컴포넌트들을 사용함으로써 개발 기간을 현저히 단축시킬
수 있고, 기존의 자바 애플리케이션도 쉽게 CSF 내에서 서
비스로 변환해 사용 가능하다.
그렇다면 JSF와 CSF는 서로 다른 프레임워크일까.
J2EE나 기타 스펙을 많이 접해본 사람은 이미 알아 차렸을
것이다. JSR(Java Specification Request)이 어느 정도의
단계에 가면 스펙 작업에 참여한 업체 또는 개인이 이에 대한
참조구현(Reference Implemetation)을 만들어 배포하게 되
고 이를 바탕으로 여러 업체와 개인이 스펙을 만족하는 제품
을 만들어 출시하게 된다. JSF는 JSR-111로써 스펙 작업이
계속적으로 진행되고 있고, 이에 대한 참조구현으로 CSF를
HP-Bluestone에서 발표한 것이다. 이번 연재에서는 CSF에
대한 분석 및 서비스 개발을 주 내용으로 할 것이다. 이는 특
정 업체가 판매하는 제품이 아니며 JCP(Java Community
Process)의 절차에 의해 표준 스펙으로 확정될 것으로 확신
한다.
범용적인 개발 방법을 제공하는 CSF
서버 기반 애플리케이션을 개발할 때 공통적으로 사용되는
부분이 많다. 몇 가지 예를 들면, 서버 애플리케이션의 라이
프사이클, 관리, 환경설정, 서버 애플리케이션간의 상호작용
등으로 공통적인 부분이 많이 존재할 것이다. 많은 프로젝트
를 하다 보면 이전 프로젝트에서 사용했던 모듈을 가져다가
사용하는 경우도 있고, 새롭게 개발하는 경우도 허다하다. 이
러한 이중 작업을 피하고 서버 애플리케이션 개발시 필요로
하는 기능들에 대한 범용적인 개발 방법을 제공하는 것이
CSF의 목표이자 정의다. 그렇다면 여기서 언급하는‘서비
스’는 무엇을 의미하는 것일까. 서비스라는 말은 실생활에서
다양한 의미로 사용되는데, CSF에서 의미하는 서비스의 정
의는 다음과 같다.
“서비스는 한 개 이상의 컴포넌트들의 집합으로 특정 영역에 대한 완전
한 솔루션을 제공한다. 예를 들어 프로토콜 핸들러, 잡 스케쥴러, 서블릿
컨테이너 등이 있다.”
CSF는 이러한 서비스 중심적인 애플리케이션을 작성하는
데 필요한 기본 바탕을 제공해 주며 소프트웨어 벤더(ISV)들
에 네이밍(Naming) 서비스, 관리(Management) 서비스,
로깅 서비스, 보안 서비스 등을 하부구조로 제공해 준다.
CSF의 장점
◆ 시기적절한 애플리케이션 개발(Timely Application Development) :
서비스는 모든 애플리케이션의 하부구조(subsystem)이고 서버는
특정 업무 영역에 맞게 만들어진 서비스와 기존의 검증된 서비스를 조
합해 만들어진다. 커다란 볼륨의 서버보다는 커스터마이즈된 작은 서
비스에 집중함으로써 시스템 디자인 시간을 크게 줄일 수 있다.
◆ 소프트웨어 품질 향상(Software Quality Improvement) : 검증되고
테스트를 거친 서비스를 재사용함으로써 애플리케이션의 품질을 높이
고 모듈 유닛을 수월하게 테스트할 수 있다.
◆ 상호운용(Interoperability) : 프레임워크의 잘 정의된 인터페이스는
Happy Hacking
24 인사이드 리눅스
JMX(Java Management Extensions)는 이름에서 짐작할
수 있듯이 시스템 관리를 위한 API 집합이다. 현재 최종 릴리즈
까지 스펙이 확정됐으며 많은 자바 애플리케이션 서버에서 이 기
술을 사용해 애플리케이션 서버를 관리하고 있다. JMX는 자바
애플리케이션을 손쉽게 관리할 수 있도록 해주며 원격 시스템 관
리를 가능하게 해준다. JMX의 구조는 Instrumentation 레벨,
에이전트 레벨, 분산 서비스 레벨로 나뉜다.
Instrumentation 레벨은 관리하고자 하는 자바 객체가 구현
해야 할 인터페이스, 동적으로 객체를 관리하기 위한 방법, 관리
하는 객체 내용의 지속성(Persistence) 관리에 대해 정의하고
있다. 이 레벨에서 다양한 MBean(Management Bean)을 정
의하고 있다. Mbean에는 Standard Mbean, Dynamic
Mbean, Open Mbean, Model Mbean 등이 있으며, 주로 동
적인 관리를 위해서 Model Mbean을 많이 사용한다.
Instrumentation 레벨에서 주로 관리하고자 하는 객체에
초점이 맞춰진 반면, 에이전트 레벨에서는 Mbean과 관리 애
플리케이션(예를 들어 애플리케이션 서버 관리 콘솔) 사이에서
중계자 역할을 한다. 에이전트 레벨은 Mbean 서버, 관리대상
자원들, 최소한 한 개 이상의 프로토콜 어댑터/커넥터(예를 들
어 HTTP를 통한 관리를 위한 HTTP 프로토콜 어댑터) 로 구
성된다.
분산 서비스 레벨은 지금은 정확한 정의하게 돼있지 않지만
개략적인 내용은 JMX 매니저를 만들기 위한 인터페이스를 제
공한다. 자세한 스펙은 http://www.jcp.org/jsr/detail/3.jsp
에서 참고할 수 있다.
시스템 관리를 위한 API의 집합, JMX
<그림 1> CSF 환경
비즈니스솔루션1 비즈니스솔루션n
코어 서비스 프레임워크
JVM(Java Virtual Machine)
운영체제




http://open.egovframe.go.kr/projects/aradon/forum


Restlet소개

약력

웹과 자바는 이미 널리 알려진 대로 긴 역사를 가지고 있다. 1994년에 만들어진 이후로 자바는 java.net 패키지와 HttpURLConnection 클래스를 이용하는 특정 HTTP 클라이언트를 포함하고 있다. 
당시 애플릿은 기존 웹 서버로 콜백을 수행하기 위하여 웹 브라우저상에서 실행되는 인기있는 기술이었다. HTTP 클라이언트를 이용하는 것은 이러한 작업을 하기에 좋은 방법이었으며, 방화벽과 관련된 보안 문제를 제한하였다.

그 이후로 1998년 즈음, HTTP 서버상의 동적 컨텐츠 생성을 위한 한 방법으로서 서블릿 API가 소개되었다. 서블릿 API는 HTTP 요청/응답 주기를 객체지향적인 모델로 표현하려고 하였다. 
자매 스펙인 자바 서버 페이지(JSP)와 함께, 서블릿 API는 자바 테크놀로지를 기업환경으로 가져가도록 하는데 크게 이바지하였다. 
자바 테크놀로지를 사용하는 애플리케이션에서는 개발자는 보통 “모델 2” 접근법이라 알려져 있기도 한 객체지향적인 MVC (Model-View-Controller) 디자인 패턴을 도입하였다. 
이 모델에서 서블릿은 컨트롤러로서, JSP 페이지는 뷰로서, 그리고 자바빈(JavaBean) 객체는 모델로서 수행된다.

같은 시기에 XML 표준이 W3C 워킹 그룹에서 출현하였다. XSLT, XSL-FO, XPATH 표준과 함께, XML은 서블릿과 JSP 페이지에 필적하는 동적 페이지를 생성하는 새로운 방법을 제공해 주었다. 
그 결과 XML은 모든 자바 플랫폼과 JSP에 받아들여져 XML 문서를 생성할 수 있도록 발전되었다. 

또 다른 방향은 아파치 코쿤 프로젝트를 시작한 Stefano Mazzocchi에 의해 주도된 것인데, 관심의 분리(separation of concern)과 컴포넌트 지향(component-oriented) 디자인 개념에 따라 구축된 XML 퍼블리싱 프레임워크(XML publishing framework)였다.

2000년, 스트러츠(Struts) 프로젝트에서는 기존 모델2/MVC 패턴에 따라 액션(Action)이라 불리는 표준 컨트롤러를 정의하였다. 
스트러츠에서는 ActionForms를 사용하여 모델과 뷰 간의 애플리케이션 상태를 교환한다. 스트러츠는 특히 폼 처리에 있어 순수 서블릿이 제공하는 것보다 더 높은 수준의 추상화를 제공하여 빠르게 인기를 얻었다. 
그 후  수많은 다른 프레임워크들이 비슷한 문제를 해결하기 위해 나타났다. 가장 주목할 만한 것은 Spring인데, 스트러츠보다 더 포괄적인 자바/J2EE 애플리케이션 프레임워크이며 MVC 접근법 또한 구현하고 있다.

같은 해 HTTP와 URI 스펙의 공저자이며 아파치 HTTP 서버의 핵심 기여자였던 Roy T. Fielding은 소프트웨어 아키텍처에 관한 논문을 작성하였다. 이 논문의 5장에서 그는 공식적으로 웹을 지원하는 아키텍처 스타일을 정의하였고 그것을 REST(REpresentational State Transfer)라 이름지었다. REST는 객체지향과는 대조적으로 자원이 도메인의 식별가능한 개념(객체에 필적하는)들을 표현하는 자원지향(resource-oriented)이라는 새로운 패러다임을 정의했다. 자원은 표준 URI(URL이나 URN)를 이용하여 참조되며 통일된 인터페이스를 통해 컴포넌트(브라우저, 서버, 프록시, 게이트웨이 등)에 의해 조작된다. 이러한 인터페이스는 한정된 동사의 목록을 가지는데, 본질적으로는 HTTP 메소드들이다. 또한 자원은 절대로 직접적으로 교환되지 않으며 오직 그 상태에 대한 표현에 의해 교환된다. 커넥터(Connector)는 예를 들자면 HTTP 프로토콜의 클라이언트 측을 구현하는 컴포넌트들간의 표현들의 통신을 가능하게 해주는 아키텍처 요소이다.

서블릿의 제한점

2003년 말, Jetty 웹 컨테이너의 저자이며 서블릿 스펙의 기여자인 Greg Wilins는 서블릿에 관한 몇 가지 문제들을 블로그에 올렸다:

l  프로토콜상의 관심사항과 애플리케이션의 관심사항간의 명확한 분리가 없다.

l  블록IO상의 가정에 기인한 비블록 NIO의 완전한 이점을 누릴 수 없다.

l  완전한 서블릿 웹 컨테이너는 오히려 많은 애플리케이션들을 지나치게 제한(overkill)한다.

그는 정말로 프로토콜에 독립적이며 컨텐츠와 그것의 메타데이터를 노출하는 컨텐틀릿(contentlet)을 정의해줄 새로운 API를 제정하자고 제안하였다. 
이러한 생각은 Restlet 프로젝트를 만드는데 많은 부분을 시사하고 또 영감을 불어넣었다. 이후 블로그 포스팅에서 그는 왜 컨텐틀릿과 같은 개념을 가지지 않는 현 서블릿 API가 비블록 NIO API를 효율적으로 사용하는 것을 제한하는지에 관해 상세하게 설명했다. 
이는 전통적으로 처리해야 할 각각의 HTTP 요청을 별도의 쓰레드를 이용하도록 되어있기 때문이다. 그는 더 나아가 이 포스팅에서 차세대 서블릿에 관해서도 설명하고 있다.

또 다른 주요 이슈는 API가 애플리케이션 개발자들로 하여금 애플리케이션이나 사용자 세션 수준의 세션 상태를 메모리에 직접 저장하도록 조장한다는 점이다. 
이것은 좋은 기능처럼 보일지는 모르겠지만, 서블릿 컨테이너의 확장성과 고가용성에 대한 주요 이슈가 되었다. 이러한 문제를 보상하기 위해 복잡한 로드 밸런싱, 세션 복제 및 퍼시스턴스 메커니즘이 구현되어야만 한다. 
그렇지만 결국 확장성은 부득이하게 겪게 된다.


Restlet의 시작

새로운 웹 사이트 개발을 시작할 때, 나는 기술적으로 가능한 만큼 REST 아키텍처 스타일을 따르기를 원했다. 
많은 연구를 거쳐 나는 자바 REST 프레임워크가 부족하다는 것을 깨달았다. 그것에 가장 근접한 프로젝트는 1060 Research에 의해 개발된 1060 NetKernel 뿐이었는데, 
나에게 필요한 것에 비해 너무 많은 기능을 가지고 있었고 REST 개념에 대한 매핑이 내가 기대한 것만큼 직접적이지는 않았다.

이러한 연유로 나는 나만의 REST 프레임워크를 서블릿 API를 기반으로 개발하게 되었다. 
그 프레임워크가 어느정도까지 잘 작동했던 것은 서블릿 API를 완전히 감췄기 때문이었다. 
나는 Greg Wilkins이 제안했던 것을 기억해 냈고 서블릿 API를 완전히 생략하기로 마음먹었다. 
운 좋게도 Jetty가 자체적인 HTTP 프로토콜 구현과 서블릿 API을 잘 분리하고 있었다. 
결국 나는 직접적으로 REST uniform 호출을 수행하는 최초의 Restlet 커넥터인 HTTP 서버 커넥터를 개발할 수 있었다.

게다가 나는 이 블로그 포스팅의 Benjamin Carlyle의 좋은 조언에 따라 자바를 이용하여 웹 상의 클라이언트측과 서버측 뷰 사이의 자연스럽지 못한 분리를 없애고 싶었다. 
오늘날의 네트워크 환경에서는 그러한 차이점이 만들어지지 말아야 하는데, 누구라도, 동일한 시간에, 웹 클라이언트와 웹 서버로서 액션을 취할 수 있어야 한다. 
REST에서 모든 컴포넌트는 필요한 만큼의 클라이언트와 서버 커넥터를 가질 수 있으므로 나는 위에서 언급한 HttpURLConnection 클래스에 기반하여 간단하게 클라이언트 HTTP 커넥터를 개발하였다. 
물론 최근에 추가된 Jakarta Commons HTTP Client 에 기반한 것과 같은 다른 구현체들도 제공될 수 있다.

몇 번을 반복하고 나서 Restlet 프로젝트를 두 부분으로 분리하는 것이 개발자에게 더 이로울 것이라는 것이 확실해 졌다. 
첫 번째 부분은 Restlet API라 불리는 일반적인 클래스 집합이며 몇 가지 헬퍼 클래스와 Restlet 구현체를 등록하는 메커니즘을 포함하고 있다. 
두 번째 부분은 Noelios Restlet 엔진이라 불리는 참조 구현체로서 몇 가지 서버 및 클라이언트 커넥터(HTTP, JDBC, SMTP 등)와 표현(문자열, 파일, XML 문서, 템플릿, 스트림 등에 기반한) 집합, 
그리고 파일 확장자에 기반하여 automatic content negotiation을 통해 디렉터리 트리로부터 정적 파일들을 처리할 수 있는 디렉터리(Directory)를 포함한다. 
2005년 11월에 처음 일반에 공개된 이후 프로젝트는 활발한 커뮤니티 사용자와 개발자가 도움을 주는 덕택에 성숙해지고 있다.

결론

복잡하게 집중화된 모델의 강력함에도 불구하고 객체지향적인 패러다임이 웹 개발에 있어 언제나 최적의 선택은 아니다. 
자바 개발자들은 이것을 깨닫고 새로운 웹 서버나 새로운 AJAX 기반의 웹 클라이언트를 개발할 때 좀 더 RESTfully하게 생각하는 것을 시작할 필요가 있다. 
Restlet 프로젝트는 여러분이 곧바로 웹 2.0에 올라탈 수 있도록 해주는 단순하지만 견고한 기반을 제공해 준다.





